# perl -w

# Documentation generator for shhArc libraries/components from
# comments in the C++ source code for shhArc.


($version, $source_code, $output) = @ARGV;

if(!defined $source_code)
{
	$source_code=qw(../../Code/);
}
if(!defined $output)
{
	$output=qw(../../Docs/ScriptingReference/ScriptReference.html);
}
if(!defined $version)
{
	$version = "(unknown version)";

}
else
{
	$version = "($version)"
}


$title = "Scripting Reference - shhArc Engine $version";


$log=qw(./log.txt);
$api_file=qw(./script.api);
$intro_file=qw(./intro.html);

@postfrom = ();
@postto = ();
@metavars = ();
@globalvars = ();
@localvars = ();

use File::Find;
use Cwd;

open(DEBUG, ">&STDOUT"); # Use this to print to console for debugging
open(LOG, "> $log");
open(STDOUT, "> $output");
open(APIFILE, "> $api_file");

print <<END;
<html><head>

<!-- This file automatically generated by shhdocgen.pl
Edit the comments in the source code, not this file. -->

<link rel="StyleSheet" href="shhArc.css">
<center><img src="shhArc_logo_light.jpg"/></center>
<title>$title</title></head><body><h1><center>$title</center></h1>

END

open my $intro, '<', $intro_file
    or die "Could not open $filename for reading: $!";
my $contents = do { local $/; <$intro> };
print $contents;

@head = ();
@chunks = ();
@sections = ();
@sectionNames = ();
$functions = ();
$body = "";
$module = "";
$module_type ="";
$item = "";
$itemdisplay = "";
$namespace = "";
$member = "";
$privilege = "";
$params = "";
$return = "";
$text = "";
$api = "";
$priv = "";
$just_got_module = 0;
$waserror = 0;

sub process_file
{
	if (! m/\.cpp$/)
	{
		if (! m/\.h$/)
		{
			return;
		}
	}
	$file = $_;

	open(SOURCE, "< $file");
	$line = 0;
	$file = getcwd."/".$file;
	
	while(<SOURCE>)
	{
		$line = $line+1;
		s:[\n]::g; # strip Windows CR
		s:[\r]::g; # strip Windows Lb
		s:[\t]::g; # strip tav

		if (m/GetMeta/)
		{
			if (m/.*GetMeta\(\s*"(.*)"\s*,\s*(.*)\s*\).*\/\/\s*(.*)/)
			#if (m/.*GetMeta\("(.*)",\s*(.*)\).*\/\/\s*(.*)/)
			{
				
				push @metavars, "<tr><td>$1</td><td>$2</td><td>$3</td></tr>\n"
			}
		}
		if (m/GetGlobal/)
		{
			if (m/.*GetGlobal\(\s*"(.*)"\s*,\s*(.*)\s*\).*\/\/\s*(.*)/)
			#if (m/.*GetGlobal\("(.*)",\s*(.*)\).*\/\/\s*(.*)/)
			{
				push @globalvars, "<tr><td>$1</td><td>$2</td><td>$3</td></tr>\n"
			}
		}
				
		if (m/GetLocal/)
		{
			if (m/.*GetLocal\(\s*"(.*)"\s*,\s*(.*)\s*\).*\/\/\s*(.*)/)
			#if (m/.*GetLocal\("(.*)",\s*(.*)\).*\/\/\s*(.*)/)
			{
				push @localvars, "<tr><td>$1</td><td>$2</td><td>$3</td></tr>\n"
			}
		}
		
		if (s:^//![ 	]::)
		{
			if (m:^/([a-z]*)[ 	]*(.*):)
			{
				if ($1 eq "library" or $1 eq "component" or $1 eq "type")
				{
					$module = $2;
					$module_type = $1;
					$priv = "";
					$just_got_module = 1;
				}
				elsif ($1 eq "global")
				{
					$module = "Global";
					$module_type = "";
					$priv = "";
					$just_got_module = 1;
				}
				elsif ($1 eq "namespace")
				{	
					$namespace = $2;
				}
				elsif ($1 eq "member")
				{	
					$member = $2;
				}
				elsif ($1 eq "privilege")
				{	
					if($privilege ne "")
					{
						$privilege .= ", ";
					}
					$privilege .= $2;
				}
				elsif ($1 eq "function" or $1 eq "message")
				{
					if ($item ne "")
					{
						warn "Syntax error at $file line $line: Improperly terminated item: $item" ;
						$waserror = 1;
					}
					$item = $2;
					$return = "";
					$return = "message" if $1 eq "message";
					$itemdisplay = $2;
					
					if ($member ne "" )
					{
						$itemdisplay = "$member:$2" if ($1 eq "function");
					}
					elsif ($namespace ne "" )
					{
						$itemdisplay = "$namespace.$2" if ($1 eq "function");
					}
					else
					{
						$itemdisplay = "$module.$2" if ($1 eq "function" and $module ne "");
					}				
					$api = "$itemdisplay(";
				}
				elsif ($1 eq "return" or $1 eq "returns")
				{
					if ($item eq "")
					{
						warn "Syntax error at $file line $line: Return without item: $2" ;
						$waserror = 1;
					}
					$return = $2;
				}
				elsif ($1 eq "param")
				{
					if ($item eq "")
					{
						warn "Syntax error at $file line $line: Param without item: $2";
						$waserror = 1;
					}
					$2 =~ m/(.*)[ 	](.*)/;
					$params .= "<span class=\"vartype\">$1</span> " . 
							  "<span class=\"varname\">$2</span>, ";
					$api .= "$2, ";
				}
				elsif ($1 eq "priv")
				{
					$priv = $2;
				}
				else
				{
					warn "Syntax error at $file line $line: Unknown autodoc tag /$1 $2";
					$waserror = 1;
				}
			}
			else
			{
				$text .= $_ . "\n";
			}
		}
		elsif ($just_got_module == 1)
		{
			@functions = sort { $a->{name} cmp $b->{name} } @functions;
			foreach $func (@functions) 
			{
				$text = $func->{body};
				$body .= $text;
			}

			#push @chunks, $body;
			push @chunks, $body;
					

			$sorter = $module;
			$sorter .= "                                                                   ";   
			$sorter = substr($sorter, 0, 50);  
			$body = $sorter;
			$functions = ();
		

			$just_got_module = 0;
                            

			$moduleheader = "";
			$privbrack = " ($priv ${module_type})";
			$privbrack =~ s: \):\):g;
			$privbrack =~ s:\( :\(:g;
			$privbrack =~ s:\(\)::g;
			$text =~ m/^([^.]*\.)/;
			push @head, "<a href=\"#$module-$priv-$module_type\">$module$privbrack</a> - $1\n";
			$privtitle = "";
			$privtitle = " ($priv privilege)" if $priv ne "";
			$moduleheader .= $sorter;
			$moduleheader .= "<p><hr width=\"90%\" align=\"center\"><div align=\"center\"><h2><a name=\"$module-$priv-$module_type\">$module ${module_type}$privtitle</a></h2></div>\n<p><center>$text</center>\n\n";
			
			push @sections, $moduleheader;
			push @sectionNames, $sorter;
			$text = "";
			$priv = "";
		}
		elsif ($item ne "")
		{
			$definition = "";
			
			$params =~ s/, $//g;
			$params = "($params)";
			if($privilege eq "")
			{
				$privilege .= "All";
			}
			$privileges = "Privilege: ";
			$privileges .= $privilege;
			$description = "Description: ";
			$description .= $text;


			# warn "Syntax error at $file line $line: Warning thing $module$item $params $return $itemdisplay";
			$definition .= <<END;
<p><table align=center border=1 cellpadding=3 cellspacing=0 width="99%">
<tr><td class="command"><a name="$module$item">
<span class="vartype">$return</span>
<span class="command">NOLINK${itemdisplay}END</span>$params
END
			if($member ne "" && $member ne "shhCONSTRUCTOR")
			{	
				$membertext = "Member: ";
				$membertext .= $member;
				$membertext .= " (replace token ";
				$membertext .= $member;
				$membertext .= " with variable name)";
				$definition .= <<END;
</td></tr><tr><td class="description">$membertext</td></tr>
END
			}
			$definition .= <<END;
</td></tr><tr><td class="description">$privileges</td></tr>
</td></tr><tr><td class="description">$description</td></tr></table>
END

			# Hyperlinks to this item
			push @postfrom, "$itemdisplay";
			push @postto, "<a href=\"#$module$item\">$itemdisplay</a>";
			# Finish Agent API
			if ($return ne "message")
			{
				$api .= ")";
				$api =~ s/, \)/\)/;
				$text =~ s/\n/ /g;
				# replace the space at the end of the line if there isn't a '.' anywhere (due to sloppy documentation!)
				$text =~ s/ $/\./ if ! m/\./;
				# match the first sentence (up to a '.')
				$text =~ m/^([^.]*\.)/;
				# ignore operator overloading, as it isn't helpful
				if (! ($api =~ m/\.[\*\+\/\-]\(/))
				{
					print APIFILE "${api}$1\n";
				}
			}


			$body .= $definition;
			$definition = "";
			push @functions,  { name => "$item",  body => "$definition" };		

			$api = "";
			$namespace = "";
			$member = "";
			$privilege = "";
			$item = "";
			$params = "";
			$return = "";
			$text = "";
		}
	}
}



find(\&process_file, $source_code);

# Fill in config vars
push @head,"<a href=\"#Config-vars\">Config Variables</a> - Engine parameters you can alter.
\n";
$metavarsjoined = join("", sort(@metavars));
push @head, "<p><hr width=\"90%\" align=\"center\"><div align=\"center\"><h2><a name=\"Config-vars\">Meta variables</h2>\n<p><center>Meta variavles can not be got or set from script</center>\n\n<p><table align=center border=1 cellpadding=3 cellspacing=0 width=\"99%\"><tr><td>Variable name</td><td>Default value</td><td>Description</tr></tr>$metavarsjoined</table>";

$globalvarsjoined = join("", sort(@globalvars));
push @head, "<p><hr width=\"90%\" align=\"center\"><div align=\"center\"><h2><a name=\"Config-vars\">Global variables</h2>\n<p><center>Read these with shh.GetGlobal and alter them with shh.SetGlobal</center>\n\n<p><table align=center border=1 cellpadding=3 cellspacing=0 width=\"99%\"><tr><td>Variable name</td><td>Default value</td><td>Description</tr></tr>$globalvarsjoined</table>";

$localvarsjoined = join("", sort(@localvars));
push @head, "<p><hr width=\"90%\" align=\"center\"><div align=\"center\"><h2><a name=\"Config-vars\">Local variables</h2>\n<p><center>Read these with shh.GetLocal and alter them with shh.SetLocal</center>\n\n<p><table align=center border=1 cellpadding=3 cellspacing=0 width=\"99%\"><tr><td>Variable name</td><td>Default value</td><td>Description</tr></tr>$localvarsjoined</table>";


# Sort into order
#$head = join("<br>", sort @head);
@sortedhead = sort @head;
@done = {};
$head = "";
for ($i = 0; $i <= $#sortedhead; ++$i)
{
	if (not grep { $_ eq $sortedhead[$i] } @done) 
	{
		$head .= $sortedhead[$i];
		$head .="<br>";
		push @done, $sortedhead[$i];
	}
}


#push @chunks, $body; # adds last read module as it wont have been added yet
push @chunks,  { name => $sorter,  body => $body };	
shift @chunks;

$body = "";
@sections = sort @sections;
@sectionNames = sort @sectionNames;
#@chunks = sort @chunks;
@chunks = sort { $a->{name} cmp $b->{name} } @chunks;

@done = {};
#$body = join(" ", sort @chunks);

#for ($i = 0; $i <= $#chunks; ++$i)
$i = 0;
foreach $chunk (@chunks) 
{
	
	$length = length $sectionNames[$i];
	if (not grep { $_ eq $sectionNames[$i] } @done) 
	{
		$text = substr($sections[$i], 50);
		$body .= $text;
		push @done, $sectionNames[$i];
	}
	
	$text = substr($chunk, 50);
	$body .= $text;
	$body .= " ";
	++$i;
}

# Add hyperlinks to body text
for ($i = 0; $i <= $#postfrom; ++$i)
{
	$from = $postfrom[$i];
	$to = $postto[$i];
	$from =~ s/\./\\./g;
	$from =~ s/\*/\\*/g;
	$from =~ s/\+/\\+/g;
	$body =~ s/\b$from\b/$to/g;
}
# And remove the NOLINK tags from the items which shouldn't
# have hyperlinks, but have the same text (e.g. the actual title
# of a function itself)
for ($i = 0; $i <= $#postfrom; ++$i)
{
	$from = $postfrom[$i];
	$fromorig = $from;
	$from =~ s/\./\\./g;
	$from =~ s/\*/\\*/g;
	$from =~ s/\+/\\+/g;
	$body =~ s/\bNOLINK${from}END\b/$fromorig/g;
}

# Special case for global namespace
$body =~ s/Global\.//g;
$body =~ s/shhCONSTRUCTOR://g;

print $head . "<p>\n";
print $body;
print "</body></html>";


